# ПЛАН РЕАЛИЗАЦИИ СИСТЕМЫ ПАРСИНГА

## Назначение документа

Последовательность разработки компонентов системы, построенная по принципу технических зависимостей: от базовых компонентов к сложным функциям.

Все ссылки ведут на блоки в [architecture.md](dont-know/architecture.md).

---

## Этап 1: Инфраструктура загрузки данных

**Цель:** Создать подключение к PostgreSQL и скрипты загрузки артикулов и прокси.

**Компоненты для реализации:**
- [МЕХАНИКА-DB](dont-know/architecture.md#механика-db-атомарная-выдача-задач) — подключение к PostgreSQL, создание необходимых таблиц для хранения артикулов и прокси
- [СКРИПТЫ-001](dont-know/architecture.md#скрипты-001-загрузка-артикулов) — скрипт загрузки артикулов в БД
- [СКРИПТЫ-002](dont-know/architecture.md#скрипты-002-загрузка-прокси) — скрипт загрузки прокси в БД
- [СКРИПТЫ-003](dont-know/architecture.md#скрипты-003-очистка-таблиц) — скрипт очистки таблиц (для тестирования)

**Зависимости:** Нет (базовый этап)

**Результат этапа:**
- Подключение к PostgreSQL настроено
- Созданы необходимые таблицы для артикулов и прокси
- Можно загружать артикулы и прокси через скрипты

---

## Этап 2: State Machine и управление прокси

**Цель:** Реализовать управление жизненным циклом артикула и пул прокси с атомарной выдачей.

**Компоненты для реализации:**
- [МЕХАНИКА-DB](dont-know/architecture.md#механика-db-атомарная-выдача-задач) — создание необходимых полей в таблицах для state machine артикулов
- [МЕХАНИКА-STATE-MACHINE](dont-know/architecture.md#механика-state-machine-state-machine-артикула) — переходы артикула через состояния NEW → CATALOG_PARSING → CATALOG_PARSED → VALIDATING → VALIDATED → OBJECT_PARSING
- [МЕХАНИКА-PROXY](dont-know/architecture.md#механика-proxy-менеджмент-прокси) — атомарная выдача прокси, блокировка при проблемах, смена прокси без возврата задачи

**Зависимости:** Этап 1 (требуется БД)

**Результат этапа:**
- Артикулы могут переходить через состояния state machine
- Прокси атомарно выдаются воркерам, блокируются при проблемах
- Воркер может сменить прокси во время работы

---

## Этап 3: Детекторы и обработка состояний

**Цель:** Реализовать распознавание состояний страницы и обработку всех возможных ситуаций (капчи, блокировки, ошибки).

**Компоненты для реализации:**
- [МЕХАНИКА-DETECTORS](dont-know/architecture.md#механика-detectors-детекторы-состояний-страницы) — детекторы состояний из avito-library (каталог, карточка, капча, блокировки, удалённое объявление)
- [МЕХАНИКА-RETRY](dont-know/architecture.md#механика-retry-обработка-состояний-детекторов) — классификация действий по детекторам, обработка капч, блокировок прокси, финальных состояний

**Зависимости:** Этап 2 (требуется механизм смены прокси)

**Результат этапа:**
- Система может определить состояние любой страницы
- Реализована универсальная обработка капч, блокировок, ошибок
- Одна общая функция обработки для всех типов задач

---

## Этап 4: Парсинг каталогов

**Цель:** Реализовать парсинг каталога по артикулу с чекпоинтами и восстановлением.

**Компоненты для реализации:**
- [МЕХАНИКА-DB](dont-know/architecture.md#механика-db-атомарная-выдача-задач) — создание необходимых таблиц для очереди catalog_tasks и сохранения объявлений из каталогов
- [МЕХАНИКА-COORDINATOR](dont-know/architecture.md#механика-coordinator-координатор-страниц-pageprovider) — координатор страниц (page_provider) для обмена страницами между парсером и воркером
- [МЕХАНИКА-CATALOG](dont-know/architecture.md#механика-catalog-парсинг-каталога) — парсинг каталога через `parse_catalog_until_complete` из avito-library, чекпоинты по страницам

**Зависимости:** Этап 3 (требуются детекторы и retry-логика)

**Результат этапа:**
- Можно спарсить каталог по артикулу (список объявлений)
- Парсинг восстанавливается с чекпоинта при сбое
- Автоматическая обработка капч и смена прокси при блокировках

---

## Этап 5: Парсинг объявлений

**Цель:** Реализовать парсинг детальной информации из карточек объявлений.

**Компоненты для реализации:**
- [МЕХАНИКА-DB](dont-know/architecture.md#механика-db-атомарная-выдача-задач) — создание необходимых таблиц для очереди object_tasks и расширение таблиц для хранения детальной информации объявлений
- [МЕХАНИКА-OBJECTS](dont-know/architecture.md#механика-objects-парсинг-объявлений) — парсинг карточек объявлений, обработка через детекторы, сохранение в БД

**Зависимости:** Этап 4 (требуется механизм парсинга и обработки состояний)

**Результат этапа:**
- Можно спарсить карточку объявления (title, description, price, views, характеристики)
- Обработка удалённых объявлений (REMOVED_DETECTOR_ID)

---

## Этап 6: Воркеры и масштабирование

**Цель:** Реализовать многопроцессорную систему воркеров с динамическим распределением между типами задач.

**Компоненты для реализации:**
- [МЕХАНИКА-XVFB](dont-know/architecture.md#механика-xvfb-виртуальные-дисплеи-xvfb) — виртуальные дисплеи для headless-браузеров, маппинг worker_id → DISPLAY
- [МЕХАНИКА-WORKERS](dont-know/architecture.md#механика-workers-управление-воркерами) — запуск Browser Workers и Validation Workers через `asyncio.create_subprocess_exec`, мониторинг, перезапуск при падении
- [МЕХАНИКА-HEARTBEAT](dont-know/architecture.md#механика-heartbeat-heartbeat-и-возврат-задач) — отслеживание зависших задач, возврат задач в очередь при timeout
- [МЕХАНИКА-DYNAMIC](dont-know/architecture.md#механика-dynamic-динамическое-распределение-воркеров) — динамическое переключение воркеров между catalog и object задачами, лимиты MAX_CATALOG_WORKERS и MAX_OBJECT_WORKERS (базовая реализация для обычного режима, расширение для REPARSE_MODE в Этапе 8)

**Зависимости:** Этап 5 (требуются все механики парсинга)

**Результат этапа:**
- Система работает с множеством параллельных воркеров
- Воркеры динамически переключаются между парсингом каталогов и объявлений
- Автоматический перезапуск упавших воркеров
- Зависшие задачи возвращаются в очередь

---

## Этап 7: Валидация объявлений

**Цель:** Реализовать фильтрацию нерелевантных объявлений через механическую и ИИ-валидацию.

**Компоненты для реализации:**
- [МЕХАНИКА-DB](dont-know/architecture.md#механика-db-атомарная-выдача-задач) — создание необходимых таблиц для хранения результатов валидации
- [МЕХАНИКА-PRICE-FILTER](dont-know/architecture.md#механика-price-filter-фильтрация-по-минимальной-цене) — фильтрация объявлений по MIN_PRICE при выборке для валидации
- [МЕХАНИКА-VALIDATION](dont-know/architecture.md#механика-validation-валидация-объявлений) — механическая валидация (стоп-слова, ценовая проверка оригинальности), ИИ-валидация через Fireworks AI, три проверки MIN_VALIDATED_ITEMS

**Зависимости:** Этап 6 (требуется система воркеров, включая Validation Workers)

**Результат этапа:**
- Объявления фильтруются по цене (MIN_PRICE)
- Отсев нерелевантных объявлений (стоп-слова, подозрительно дешёвые)
- ИИ-валидация через Fireworks AI (pay-as-you-go)
- Артикулы с недостаточным количеством объявлений отклоняются (REJECTED_BY_MIN_COUNT)

---

## Этап 8: Режим повторного парсинга

**Цель:** Реализовать повторный сбор данных о просмотрах для анализа динамики.

**Компоненты для реализации:**
- [МЕХАНИКА-DB](dont-know/architecture.md#механика-db-атомарная-выдача-задач) — создание необходимых таблиц для фильтров повторного парсинга
- [МЕХАНИКА-DYNAMIC](dont-know/architecture.md#механика-dynamic-динамическое-распределение-воркеров) — расширение для режима повторного парсинга (все Browser Workers работают в режиме object parsing, MAX_CATALOG_WORKERS игнорируется)
- [МЕХАНИКА-REPARSE](dont-know/architecture.md#механика-reparse-режим-повторного-парсинга) — режим повторного парсинга (REPARSE_MODE=true), парсинг только ранее спарсенных объявлений, проверка MIN_REPARSE_INTERVAL_HOURS
- [МЕХАНИКА-REPARSE-FILTERS](dont-know/architecture.md#механика-reparse-filters-фильтры-повторного-парсинга) — фильтры для ограничения списка объявлений (по avito_item_id или артикулам)
- [СКРИПТЫ-005](dont-know/architecture.md#скрипты-005-загрузка-фильтра-объявлений) — скрипт загрузки фильтра объявлений
- [СКРИПТЫ-006](dont-know/architecture.md#скрипты-006-загрузка-фильтра-артикулов) — скрипт загрузки фильтра артикулов

**Зависимости:** Этап 7 (требуется полная система парсинга и валидации)

**Результат этапа:**
- Можно повторно парсить ранее спарсенные объявления для сбора новых данных о просмотрах
- Фильтры позволяют ограничить список объявлений для повторного парсинга
- Проверка минимального интервала между парсингами
- Каждый парсинг создаёт новую строку в таблице результатов

---

## Этап 9: Аналитика просмотров

**Цель:** Реализовать расчёт динамики изменения просмотров между замерами.

**Компоненты для реализации:**
- [МЕХАНИКА-DB](dont-know/architecture.md#механика-db-атомарная-выдача-задач) — создание необходимых таблиц для хранения результатов аналитики
- [МЕХАНИКА-ANALYTICS](dont-know/architecture.md#механика-analytics-аналитика-просмотров) — расчёт метрик (views_diff, time_diff, efficiency_coefficient) между первым и последним замером
- [СКРИПТЫ-007](dont-know/architecture.md#скрипты-007-генерация-аналитики-просмотров) — скрипт генерации таблицы аналитики

**Зависимости:** Этап 8 (требуется режим повторного парсинга для накопления нескольких замеров)

**Результат этапа:**
- Таблица аналитики с динамикой просмотров для каждого объявления
- Коэффициент эффективности (views_diff / time_diff)
- Только объявления с двумя и более замерами

---

## Этап 10: Утилиты и мониторинг

**Цель:** Реализовать инструменты для мониторинга и обслуживания системы.

**Компоненты для реализации:**
- [СКРИПТЫ-004](dont-know/architecture.md#скрипты-004-дашборд) — дашборд мониторинга (задачи по статусам, прокси, валидация, активные воркеры)
- [СКРИПТЫ-008](dont-know/architecture.md#скрипты-008-расширенная-очистка-таблиц) — расширенная очистка всех таблиц системы

**Зависимости:** Этап 9 (финальный этап, требуется полная система)

**Результат этапа:**
- Дашборд для наблюдения за состоянием системы в реальном времени
- Расширенная очистка всех таблиц (прокси, артикулы, задачи, фильтры, результаты)

---

**✅ ПЛАН ЗАВЕРШЁН**

Полная последовательность реализации от базовых компонентов до финальных утилит.
