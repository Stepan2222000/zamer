# ГЛАВНЫЙ ПАЙПЛАЙН ПРОГРАММЫ

## 0. Подготовка данных (до запуска контейнера)

**Описание:** Загрузка артикулов и прокси в БД через скрипты.

**Действия:**
- Запуск скрипта загрузки артикулов → см. [СКРИПТЫ-001]
- Запуск скрипта загрузки прокси → см. [СКРИПТЫ-002]

**Переход к следующему этапу:** После загрузки данных запускается контейнер с воркерами.

---

## 0А. Режим повторного парсинга (альтернативный пайплайн)

**Описание:** Повторный сбор данных о просмотрах ранее спарсенных объявлений для анализа динамики.

**Условие активации:** `REPARSE_MODE=true` в Docker Compose

**Подготовка (опционально):**
- Загрузка фильтра объявлений через скрипт → см. [СКРИПТЫ-005]
- Загрузка фильтра артикулов через скрипт → см. [СКРИПТЫ-006]

**Отличия от обычного режима:** → см. [МЕХАНИКА-REPARSE]

**Переход к следующему этапу:** Контейнер запускается в режиме повторного парсинга.

---

## 1. Старт контейнера и инициализация

**Описание:** Инициализация окружения и запуск воркеров.

**Действия:**
- Чтение конфигурации из переменных окружения Docker Compose
- Инициализация виртуальных дисплеев Xvfb → см. [МЕХАНИКА-XVFB]
- Подключение к PostgreSQL, создание таблиц при отсутствии
- Запуск воркеров через asyncio subprocesses → см. [МЕХАНИКА-WORKERS]

**Переход к следующему этапу:** Воркеры начинают обрабатывать батчи артикулов.

---

## 2. Обработка батча артикулов

**Описание:** Система обрабатывает батч артикулов в статусе NEW из БД.

**Действия:**
- Browser Workers берут задачи на парсинг каталогов → см. [МЕХАНИКА-CATALOG], [МЕХАНИКА-DB]
- Validation Workers параллельно валидируют спарсенные объявления → см. [МЕХАНИКА-PRICE-FILTER], [МЕХАНИКА-VALIDATION]
- Browser Workers динамически переключаются на парсинг объявлений → см. [МЕХАНИКА-OBJECTS], [МЕХАНИКА-DYNAMIC]
- Heartbeat механизм отслеживает зависшие задачи → см. [МЕХАНИКА-HEARTBEAT]

**Переход к следующему этапу:** Когда батч обработан, система берет следующий батч.

---

═══════════════════════════════════════

# МЕХАНИКИ И АЛГОРИТМЫ

## [МЕХАНИКА-STATE-MACHINE] State Machine артикула

**Назначение:** Управление жизненным циклом артикула через последовательность состояний.

**Переходы (только вперёд):**
1. `NEW` — артикул загружен через скрипт, ожидает обработки
2. `CATALOG_PARSING` — парсинг каталога Browser Worker'ом. Переход происходит при атомарном взятии задачи из `catalog_tasks` воркером
3. `CATALOG_PARSED` — каталог полностью спарсен (все страницы обработаны), все объявления артикула в БД, артикул готов к валидации
4. `VALIDATING` — Validation Worker начинает валидировать все объявления артикула как единый батч
5. `VALIDATED` — валидация завершена, артикул переведен в VALIDATED; затем создаются записи в `object_tasks` для прошедших объявлений
6. `OBJECT_PARSING` — парсинг объявлений, задачи берутся из `object_tasks` (финальное)
7. `REJECTED_BY_MIN_COUNT` — артикул отклонён из-за недостаточного количества объявлений после одного из этапов валидации (финальное)

**Альтернативные пути:**
Из статуса `VALIDATING` возможен переход в `REJECTED_BY_MIN_COUNT` при провале любой из трёх проверок минимального количества объявлений → см. [МЕХАНИКА-VALIDATION]

**Единица согласованности:**
- **Каталог:** Пока все страницы каталога не обработаны, артикул не переходит в CATALOG_PARSED
- **Валидация:** Объявления одного артикула валидируются как единый батч (все объявления найденного каталога вместе)

**Момент перехода NEW → CATALOG_PARSING:**
- При старте системы главный процесс создает записи в `catalog_tasks` для артикулов в статусе NEW
- Артикулы остаются в статусе NEW до взятия задачи воркером
- Переход NEW → CATALOG_PARSING происходит атомарно при вызове `acquire_catalog_task()` в воркере
- Если несколько воркеров пытаются взять задачи одного артикула, переход произойдет только один раз благодаря атомарной проверке состояния в транзакции

**Зависимости:** → см. [МЕХАНИКА-DB]

---

## [МЕХАНИКА-DETECTORS] Детекторы состояний страницы

**Назначение:** Определение текущего состояния страницы браузера для принятия решений о дальнейших действиях.

**Источник:** avito-library предоставляет функцию `detect_page_state(page)` и набор зарегистрированных детекторов.

**Принцип работы:**
- Детекторы выполняются после каждого `page.goto()` и значимых действий
- Проверяются в порядке приоритета: сначала успешные состояния (каталог/карточка), затем проблемы (капча/блокировка)
- Возвращают строковый идентификатор состояния
- Если ни один детектор не сработал → возвращается `NOT_DETECTED_STATE_ID`

**Полный список детекторов:**

**Успешные состояния:**
- `CATALOG_DETECTOR_ID` — страница каталога с объявлениями
- `CARD_FOUND_DETECTOR_ID` — карточка объявления загружена

**Блокировки прокси:**
- `PROXY_BLOCK_403_DETECTOR_ID` — HTTP 403, прокси заблокирован
- `PROXY_AUTH_DETECTOR_ID` — ошибка аутентификации прокси

**Капчи и интерактивные элементы:**
- `CAPTCHA_DETECTOR_ID` — обнаружена Geetest капча
- `CONTINUE_BUTTON_DETECTOR_ID` — кнопка "Продолжить" (обычно после капчи)
- `PROXY_BLOCK_429_DETECTOR_ID` — HTTP 429, rate limit (решается через капчу)

**Проблемы с объявлением:**
- `REMOVED_DETECTOR_ID` — объявление снято с публикации

**Неопределенное состояние:**
- `NOT_DETECTED_STATE_ID` — ни один детектор не распознал страницу

**Обработка результатов:** → см. [МЕХАНИКА-RETRY]

**Переиспользование кода:**
- Функция обработки результатов детекции должна быть одна общая для всех типов задач
- Логика обработки капч, блокировок прокси и ошибок НЕ дублируется между process_catalog_task и process_object_task

**Зависимости:** Используется в [МЕХАНИКА-CATALOG], [МЕХАНИКА-OBJECTS]

---

## [МЕХАНИКА-WORKERS] Управление воркерами

**Назначение:** Запуск и мониторинг независимых процессов-воркеров.

**Запуск:**
- Каждый воркер — независимый процесс через `asyncio.create_subprocess_exec`
- Browser Workers получают уникальный worker_id и DISPLAY
- Браузер создается при взятии первой задачи (lazy initialization) с привязкой к DISPLAY
- Validation Workers работают без браузера

**Смена прокси в Browser Workers:**
- Воркер может менять прокси во время работы без возврата задачи в очередь
- Алгоритм и детали → см. [МЕХАНИКА-PROXY]

**Мониторинг:**
- Главный процесс проверяет статус subprocesses
- При падении процесса: освобождение ресурсов (прокси, задачи), перезапуск

**Изоляция:**
- Воркеры не взаимодействуют напрямую
- Вся координация через PostgreSQL

**Зависимости:** → см. [МЕХАНИКА-XVFB], [МЕХАНИКА-HEARTBEAT], [МЕХАНИКА-DYNAMIC]

---

## [МЕХАНИКА-DYNAMIC] Динамическое распределение воркеров

**Назначение:** Оптимальное использование Browser Workers через переключение между типами задач.

**Конфигурация:**
- `MAX_CATALOG_WORKERS` — максимум воркеров на парсинг каталогов
- `MAX_OBJECT_WORKERS` — максимум воркеров на парсинг объявлений
- `TOTAL_BROWSER_WORKERS` — общее число Browser Workers

**Технический механизм:**
- Режим воркера (catalog/object) хранится в памяти процесса (переменная current_mode)
- Лимиты контролируются через COUNT активных задач в транзакции:
  - `SELECT COUNT(*) FROM catalog_tasks WHERE status='processing'` < MAX_CATALOG_WORKERS
  - `SELECT COUNT(*) FROM object_tasks WHERE status='processing'` < MAX_OBJECT_WORKERS
- Алгоритм выбора задачи (при завершении текущей или при старте):
  1. Воркер пробует взять catalog_task (приоритет)
  2. Если лимит достигнут ИЛИ нет доступных catalog_tasks → пробует взять object_task
  3. Если нет задач обоих типов → воркер ждет

**Начальное состояние батча:**
- При старте батча NEW артикулов: в `object_tasks` НЕТ задач (создаются после валидации)
- Воркеры до MAX_CATALOG берут catalog_tasks атомарно
- Остальные воркеры ждут появления задач в object_tasks

**Пример:**
MAX_CATALOG=5, MAX_OBJECT=30, TOTAL=20 → первые 5 воркеров берут каталоги, остальные 15 ждут появления задач в object_tasks.

**Режим повторного парсинга:** → см. [МЕХАНИКА-REPARSE]

**Зависимости:** → см. [МЕХАНИКА-WORKERS], [МЕХАНИКА-DB], [МЕХАНИКА-REPARSE]

---

## [МЕХАНИКА-XVFB] Виртуальные дисплеи Xvfb

**Назначение:** Изолированные дисплеи для headless-браузеров.

**Алгоритм:**
- При старте контейнера: создается TOTAL_BROWSER_WORKERS дисплеев
- Маппинг: worker_id → DISPLAY (например, worker 0 → :99, worker 1 → :100)
- При запуске Browser Worker через subprocess передается DISPLAY в аргументах

**Инвариант:**
Один воркер — один дисплей — один браузер в момент времени (создаётся при первой задаче, пересоздаётся при смене прокси) — один контекст и одна страница (пересоздаются вместе с браузером).

**Зависимости:** → см. [МЕХАНИКА-WORKERS]

---

## [МЕХАНИКА-DB] Атомарная выдача задач

**Назначение:** Исключить взятие одной задачи двумя воркерами.

**Архитектура:**
Две отдельные таблицы для разных типов задач:
- `catalog_tasks` — очередь задач по парсингу каталогов
- `object_tasks` — очередь задач по парсингу объявлений

**Причины разделения:**
- Упрощение наблюдения за очередями (мониторинг, статистика по типам)
- Упрощение логики работы с задачами

**Поведение воркера:**
- Воркер выбирает таблицу в зависимости от текущего режима (каталог/объявление) → см. [МЕХАНИКА-DYNAMIC]
- Если задач нет: воркер ждет и периодически проверяет

**Особенность catalog_tasks:**
Создание записи в `catalog_tasks` и переход артикула в состояние CATALOG_PARSING — это два разных момента времени:
- Главный процесс создает `catalog_tasks` для артикулов в статусе NEW при старте
- Переход NEW → CATALOG_PARSING происходит позже, когда воркер атомарно берет задачу через `acquire_catalog_task()`
- Это позволяет создавать очередь задач заранее без блокировки артикулов

**Зависимости:** → см. [МЕХАНИКА-HEARTBEAT], [МЕХАНИКА-STATE-MACHINE], [МЕХАНИКА-DYNAMIC]

---

## [МЕХАНИКА-HEARTBEAT] Heartbeat и возврат задач

**Назначение:** Обнаружение зависших воркеров и возврат их задач.

**Алгоритм:**
- Воркер периодически обновляет heartbeat для текущей задачи (в соответствующей таблице)
- Фоновая задача главного процесса ищет задачи с просроченным heartbeat в **обеих таблицах**:
  - Проверка `catalog_tasks` на просроченные задачи
  - Проверка `object_tasks` на просроченные задачи
- Задачи с просроченным heartbeat возвращаются в статус pending

**Частично выполненная работа:**
Если каталог спарсен наполовину — чекпоинт (номер страницы) сохранен в `catalog_tasks`, новый воркер продолжает с этой страницы.

**Зависимости:** → см. [МЕХАНИКА-DB], [МЕХАНИКА-RETRY]

---

## [МЕХАНИКА-PROXY] Менеджмент прокси

**Назначение:** Управление пулом прокси с атомарной выдачей и блокировкой.

**Выдача:**
- Атомарная выборка свободного прокси (`SELECT ... FOR UPDATE SKIP LOCKED`)
- Прокси помечается «используется» с привязкой к worker_id

**Блокировка:**
- Прокси помечается «заблокирован» при детекции проблем (см. [МЕХАНИКА-RETRY])
- Механизма разблокировки нет (блокировка постоянная)

**Смена прокси во время работы:**
- При блокировке прокси воркер может сменить прокси БЕЗ возврата задачи в очередь (только для catalog задач):
  1. Закрывает текущую страницу и контекст
  2. Закрывает весь браузер
  3. Берет новый прокси из пула
  4. Запускает новый браузер с новым прокси (launch с proxy config)
  5. Создает новый контекст
  6. Создает новую страницу
  7. Продолжает работу над той же задачей (каталог с чекпоинта)
- Механизм реализован через page_provider в parse_catalog_until_complete → см. [МЕХАНИКА-COORDINATOR]
- Инвариант: один браузер в момент времени (пересоздаётся при смене прокси из-за ограничений Playwright API), один контекст и одна страница (пересоздаются вместе с браузером)

**Нет свободных:**
Воркер приостанавливает взятие задач и ждет.

**Важно:**
Блокировка прокси не зависит от задачи — одна задача может пройти через разные прокси.

**Возврат прокси при капче:**
Если капча не решается (CAPTCHA_DETECTOR_ID, CONTINUE_BUTTON_DETECTOR_ID, PROXY_BLOCK_429_DETECTOR_ID), прокси возвращается в пул вместе с задачей → см. [МЕХАНИКА-RETRY]

**Зависимости:** → см. [МЕХАНИКА-RETRY], [МЕХАНИКА-DETECTORS]

---

## [МЕХАНИКА-RETRY] Обработка состояний детекторов

**Назначение:** Обработка результатов детекции состояния страницы и принятие решений о дальнейших действиях.

**Классификация действий по детекторам:**

**1. Успешные состояния (продолжаем парсинг):**
- `CATALOG_DETECTOR_ID` → парсим каталог → см. [МЕХАНИКА-CATALOG]
- `CARD_FOUND_DETECTOR_ID` → парсим объявление → см. [МЕХАНИКА-OBJECTS]

**2. Восстанавливаемые проблемы (решаем капчу и повторяем):**
- `CAPTCHA_DETECTOR_ID` → пытаемся решить капчу
- `CONTINUE_BUTTON_DETECTOR_ID` → пытаемся решить капчу
- `PROXY_BLOCK_429_DETECTOR_ID` → пытаемся решить капчу 
- **Если капча решилась:** продолжаем с тем же прокси и задачей
- **Если капча НЕ решилась:** возвращаем задачу и прокси в очередь (статус pending)

**3. Проблемы прокси (блокируем прокси, меняем и продолжаем):**
- `PROXY_BLOCK_403_DETECTOR_ID` → блокируем прокси, меняем и продолжаем задачу
- `PROXY_AUTH_DETECTOR_ID` → блокируем прокси, меняем и продолжаем задачу

**4. Финальные состояния (задача завершена):**
- `REMOVED_DETECTOR_ID` → задача invalid (объявление снято с публикации)
- `NOT_DETECTED_STATE_ID` → задача failed без retry (неизвестное состояние страницы)

**Обработка исключений page.goto():**
При ошибках навигации (timeout, network error) выбрасывается exception, задача возвращается в очередь.

**Отсутствие retry-счетчиков:**
Система не использует счетчики попыток. Каждая задача может пройти через неограниченное количество прокси до успешного выполнения или финального состояния.

**Зависимости:** → см. [МЕХАНИКА-DETECTORS], [МЕХАНИКА-PROXY], [МЕХАНИКА-CATALOG], [МЕХАНИКА-OBJECTS]

---

## [МЕХАНИКА-CATALOG] Парсинг каталога

**Назначение:** Извлечение списка объявлений из каталога по артикулу.

**Алгоритм:**
- Воркер берет задачу из `catalog_tasks`
- Формирование URL каталога с параметром сортировки по дате
- Парсинг через `parse_catalog_until_complete` из avito-library
- Функция работает батчами страниц, при проблемах (детекция нештатных состояний) запрашивает новую страницу у воркера через координатор → см. [МЕХАНИКА-COORDINATOR], [МЕХАНИКА-RETRY], [МЕХАНИКА-DETECTORS]
- Сохранение объявлений в БД с привязкой к артикулу

**Чекпоинты:**
Номер последней обработанной страницы сохраняется в `catalog_tasks` — при возобновлении (heartbeat timeout) парсинг продолжается с места остановки.

**Зависимости:** → см. [МЕХАНИКА-COORDINATOR], [МЕХАНИКА-RETRY], [МЕХАНИКА-DB]

---

## [МЕХАНИКА-PRICE-FILTER] Фильтрация по минимальной цене

**Назначение:** Отсев объявлений с ценой ниже порога интереса.

**Момент применения:**
После полного парсинга каталога (артикул в статусе CATALOG_PARSED), при выборке объявлений для валидации.

**Алгоритм:**
- При получении объявлений артикула из БД для валидации применяется фильтр: `price >= MIN_PRICE`
- Объявления с ценой < MIN_PRICE игнорируются при выборке
- Объявления остаются в БД без изменений, просто не участвуют в процессе валидации

**Отличие от существующей ценовой валидации:**
- **MIN_PRICE** — глобальный порог интереса ("меня вообще не интересуют дешёвые объявления")
- **Ценовая валидация** в механической валидации — проверка оригинальности для конкретного артикула (топ-20%, порог 50%)
- Эти две проверки независимы и работают последовательно

**Режим повторного парсинга:** → см. [МЕХАНИКА-REPARSE]

**Зависимости:** → см. [МЕХАНИКА-VALIDATION], [МЕХАНИКА-STATE-MACHINE]

---

## [МЕХАНИКА-COORDINATOR] Координатор страниц (page_provider)

**Назначение:** Обмен Playwright-страницами между парсером каталога и воркером.

**Механизм (из avito-library):**
- `parse_catalog_until_complete` сам решает капчи на текущей странице
- При блокировке прокси вызывает `page_provider()` для получения новой страницы
- Воркер предоставляет новую страницу через page_provider (детали смены прокси → см. [МЕХАНИКА-PROXY])
- Парсинг продолжается с полученной страницы

**Зависимости:** → см. [МЕХАНИКА-CATALOG], [МЕХАНИКА-RETRY], [МЕХАНИКА-PROXY]

---

## [МЕХАНИКА-VALIDATION] Валидация объявлений

**Назначение:** Отсев нерелевантных объявлений.

**Механическая валидация:**
- Поиск стоп-слов в title/description/seller (регистронезависимо)
- Примеры: "не оригинал", "аналог", "б/у", "бу", "б.у"
- Ценовая проверка: топ-20% самых дорогих → средняя → порог 50% → отсев дешевле
- Исключение выбросов: цены > 3× медианы топ-20%

**ИИ-валидация (Fireworks AI):**
- API: Fireworks AI pay-as-you-go endpoint
- Модель: Qwen2.5-VL-32B (мультимодальная, текст + изображения)
- В запрос: объявления прошедшие механику + изображения (опционально)
- Ответ: passed_ids и rejected с причинами
- Graceful degradation: если нет FIREWORKS_API_KEY — программа останавливается

**Сохранение:**
Для каждого объявления фиксируется: тип валидации, passed, причина отклонения (конкретные стоп-слова / пояснение ИИ).

**Алгоритм валидации:**
1. Validation Worker берет артикул в статусе CATALOG_PARSED
2. Переводит артикул в статус VALIDATING
3. Получает ВСЕ объявления этого артикула из БД (без фильтров)

4. **ПРОВЕРКА #0: Минимальное количество после парсинга каталога**
   - Считаем количество объявлений ДО применения любых фильтров
   - Если < MIN_VALIDATED_ITEMS → артикул переводится в REJECTED_BY_MIN_COUNT, логируется причина отклонения, валидация завершается
   - Если >= MIN_VALIDATED_ITEMS → продолжаем

5. Применяет фильтр MIN_PRICE → см. [МЕХАНИКА-PRICE-FILTER]

6. **ПРОВЕРКА #1: Минимальное количество после фильтрации цены**
   - Считаем количество оставшихся объявлений (после фильтра MIN_PRICE)
   - Если < MIN_VALIDATED_ITEMS → артикул переводится в REJECTED_BY_MIN_COUNT, логируется причина отклонения, валидация завершается
   - Если >= MIN_VALIDATED_ITEMS → продолжаем

7. Выполняет механическую валидацию оставшихся объявлений (стоп-слова + ценовая проверка оригинальности)

8. **ПРОВЕРКА #2: Минимальное количество после механической валидации**
   - Считаем прошедшие механическую валидацию
   - Если < MIN_VALIDATED_ITEMS → артикул переводится в REJECTED_BY_MIN_COUNT, логируется причина отклонения, валидация завершается
   - Если >= MIN_VALIDATED_ITEMS → продолжаем на ИИ-валидацию

9. Отправляет прошедшие в ИИ-валидацию (если ENABLE_AI_VALIDATION=true и FIREWORKS_API_KEY установлен)

10. **ПРОВЕРКА #3: Минимальное количество после ИИ-валидации**
    - Считаем прошедшие ИИ-валидацию
    - Если < MIN_VALIDATED_ITEMS → артикул переводится в REJECTED_BY_MIN_COUNT, логируется причина отклонения, валидация завершается
    - Если >= MIN_VALIDATED_ITEMS → продолжаем

11. Сохраняет результаты валидации в `validation_results` для каждого объявления
12. **Переводит артикул в статус VALIDATED**
13. Создает записи в `object_tasks` для каждого объявления, прошедшего все проверки

**Логирование отклонений:**
При переходе артикула в REJECTED_BY_MIN_COUNT фиксируется:
- Этап проверки (после парсинга каталога / после фильтрации цены / после механической валидации / после ИИ-валидации)
- Количество объявлений на этапе
- Требуемое MIN_VALIDATED_ITEMS

**Итог:**
Дальше идут только объявления, прошедшие все валидации и проверки количества. Если артикул отклонён на любом из этапов — он переходит в REJECTED_BY_MIN_COUNT. Объявления считаются обработанными только после парсинга карточки (`OBJECT_PARSING`).

**Режим повторного парсинга:** → см. [МЕХАНИКА-REPARSE]

**Зависимости:** → см. [МЕХАНИКА-STATE-MACHINE], [МЕХАНИКА-DB]

---

## [МЕХАНИКА-OBJECTS] Парсинг объявлений

**Назначение:** Извлечение детальной информации из карточек объявлений.

**Алгоритм:**
- Browser Worker берет задачу из `object_tasks`
- Получает прокси
- Переход на URL карточки `https://www.avito.ru/{avito_item_id}`
- Детекция состояния страницы и обработка в зависимости от результата → см. [МЕХАНИКА-DETECTORS], [МЕХАНИКА-RETRY]
- При успехе (CARD_FOUND_DETECTOR_ID): парсинг через avito-library, сохранение в БД

**Зависимости:** → см. [МЕХАНИКА-RETRY], [МЕХАНИКА-PROXY], [МЕХАНИКА-DB]

---

## [МЕХАНИКА-REPARSE] Режим повторного парсинга

**Назначение:** Повторный сбор данных о просмотрах для анализа динамики изменений.

**Активация:** Переменная окружения `REPARSE_MODE=true`

**Источник объявлений для парсинга:**
- Все объявления, которые уже были спарсены в первый раз (есть записи в БД результатов)
- Применяются фильтры из таблиц фильтров → см. [МЕХАНИКА-REPARSE-FILTERS]
- Если таблицы фильтров пусты → парсим все ранее спарсенные объявления

**Создание задач:**
- При инициализации главный процесс формирует список объявлений для повторного парсинга
- Создаются записи в `object_tasks` со статусом `pending`
- Каждое объявление проходит проверку MIN_REPARSE_INTERVAL_HOURS

**Проверка минимального интервала:**
- Для каждого объявления проверяется время последнего парсинга
- Если `(NOW() - last_parsed_at) < MIN_REPARSE_INTERVAL_HOURS` → объявление пропускается
- Проверка происходит в воркере при взятии задачи из `object_tasks`

**Отличия от обычного режима:**
- Парсятся только объявления, спарсенные в первый раз
- State machine артикулов НЕ используется
- Валидация НЕ проводится
- Каталоги НЕ парсятся (catalog_tasks пуста)
- Все Browser Workers работают в режиме object parsing
- MAX_CATALOG_WORKERS игнорируется (все воркеры берут задачи из object_tasks)
- Применяются фильтры (если заполнены) → см. [МЕХАНИКА-REPARSE-FILTERS]
- Проверка минимального интервала между парсингами (MIN_REPARSE_INTERVAL_HOURS)
- При удаленном объявлении (REMOVED_DETECTOR_ID) → просто пропускаем, не сохраняем

**Отключенные проверки:**
- Фильтр MIN_PRICE не применяется
- Проверки MIN_VALIDATED_ITEMS не применяются

**Сохранение результатов:**
- Каждый парсинг создает НОВУЮ строку в таблице результатов
- Поле `parsed_at` содержит timestamp текущего парсинга
- Характеристики и другие данные берутся из карточки объявления

**Зависимости:** → см. [МЕХАНИКА-REPARSE-FILTERS], [МЕХАНИКА-DYNAMIC], [МЕХАНИКА-OBJECTS]

---

## [МЕХАНИКА-REPARSE-FILTERS] Фильтры повторного парсинга

**Назначение:** Ограничение списка объявлений для повторного парсинга.

**Таблицы фильтров:**
- Таблица фильтра объявлений — содержит список `avito_item_id`
- Таблица фильтра артикулов — содержит список артикулов

**Логика формирования списка объявлений:**
```
Список для парсинга =
  (avito_item_id из таблицы фильтра объявлений)
  UNION
  (avito_item_id объявлений артикулов из таблицы фильтра артикулов)

ЕСЛИ обе таблицы фильтров пусты:
  → берем ВСЕ ранее спарсенные объявления
```

**Загрузка фильтров:**
- Через скрипты загрузки → см. [СКРИПТЫ-005], [СКРИПТЫ-006]
- Из .txt файлов (по одному ID на строку)
- Режимы `add` и `replace`

**Обработка несуществующих объявлений:**
- Если `avito_item_id` из фильтра НЕ найден в БД → пропускаем с предупреждением в логах
- Задача для такого объявления НЕ создается

**Зависимости:** → см. [МЕХАНИКА-REPARSE], [СКРИПТЫ-005], [СКРИПТЫ-006]

---

## [МЕХАНИКА-ANALYTICS] Аналитика просмотров

**Назначение:** Расчет динамики изменения просмотров между замерами.

**Запуск:** Вручную через скрипт → см. [СКРИПТЫ-007]

**Алгоритм:**
1. Для каждого объявления определяется первый замер (MIN(parsed_at)) и последний замер (MAX(parsed_at))
2. Извлекаются данные из обоих замеров (views, timestamp)
3. Рассчитываются метрики:
   - `views_diff` = last_views - first_views
   - `time_diff` = last_parsed_at - first_parsed_at (в часах)
   - `efficiency_coefficient` = views_diff / time_diff

**Структура таблицы аналитики:**
- `avito_item_id` — ID объявления
- `articles` — артикул(ы), к которым относится объявление
- `title`, `description`, `characteristics`, `price` — данные из первого замера
- `first_views` — просмотры при первом замере
- `last_views` — просмотры при последнем замере
- `views_diff` — разница просмотров
- `time_diff` — разница во времени (часы)
- `efficiency_coefficient` — коэффициент эффективности

**Обработка объявлений без второго замера:**
- В таблицу аналитики попадают ТОЛЬКО объявления с двумя и более замерами
- Объявления с одним замером игнорируются

**Формат артикулов:**
- Если объявление относится к нескольким артикулам → хранится как строка через запятую
- Пример: "ART-001, ART-002, ART-003"

**Зависимости:** → см. [СКРИПТЫ-007]

---

# СКРИПТЫ (папка scripts)

## [СКРИПТЫ-001] Загрузка артикулов

**Назначение:** Загрузка артикулов в БД для обработки воркерами.

**Режимы:**
- `add` — добавление новых артикулов
- `replace` — полная перезапись

**Особенности:**
- Батчевая вставка по 1000 записей
- При запуске проверяет наличие таблиц, создает если отсутствуют

---

## [СКРИПТЫ-002] Загрузка прокси

**Назначение:** Загрузка прокси в БД для использования воркерами.

**Формат:** `host:port:username:password`

**Режимы:**
- `add` — добавление новых прокси
- `replace` — полная перезапись

**Особенности:**
- Батчевая вставка по 1000 записей
- Валидация формата перед загрузкой
- При запуске проверяет наличие таблиц, создает если отсутствуют

---

## [СКРИПТЫ-003] Очистка таблиц

**Назначение:** Очистка данных из БД.

**Режимы:**
- `all` — очистка всех таблиц
- `select` — выборочная очистка

**Особенности:**
- TRUNCATE CASCADE для удаления связанных данных
- Двойное подтверждение для безопасности

---

## [СКРИПТЫ-004] Дашборд

**Назначение:** Мониторинг состояния системы.

**Показывает:**
- Задачи по статусам из обеих таблиц (`catalog_tasks`, `object_tasks`)
- Прокси по статусам
- Статистика валидации
- Активные воркеры

---

## [СКРИПТЫ-005] Загрузка фильтра объявлений

**Назначение:** Загрузка списка `avito_item_id` для фильтрации повторного парсинга.

**Источник:** .txt файл (по одному ID на строку)

**Режимы:**
- `add` — добавление новых ID к существующим (с проверкой дубликатов)
- `replace` — полная перезапись таблицы фильтра

**Особенности:**
- Батчевая вставка по 1000 записей
- При запуске проверяет наличие таблицы фильтра, создает если отсутствует
- Валидация формата ID перед загрузкой

**Зависимости:** → см. [МЕХАНИКА-REPARSE-FILTERS]

---

## [СКРИПТЫ-006] Загрузка фильтра артикулов

**Назначение:** Загрузка списка артикулов для фильтрации повторного парсинга.

**Источник:** .txt файл (по одному артикулу на строку)

**Режимы:**
- `add` — добавление новых артикулов к существующим (с проверкой дубликатов)
- `replace` — полная перезапись таблицы фильтра

**Особенности:**
- Батчевая вставка по 1000 записей
- При запуске проверяет наличие таблицы фильтра, создает если отсутствует

**Зависимости:** → см. [МЕХАНИКА-REPARSE-FILTERS]

---

## [СКРИПТЫ-007] Генерация аналитики просмотров

**Назначение:** Расчет динамики изменения просмотров между замерами.

**Запуск:** Вручную через CLI

**Алгоритм:**
1. Извлекает все объявления с двумя и более замерами
2. Для каждого объявления определяет первый и последний замер
3. Рассчитывает метрики (views_diff, time_diff, coefficient)
4. Создает/обновляет таблицу аналитики с результатами

**Вывод:**
- Количество обработанных объявлений
- Количество пропущенных (с одним замером)
- Статистика по коэффициентам (min, max, avg)

**Зависимости:** → см. [МЕХАНИКА-ANALYTICS]

---

## [СКРИПТЫ-008] Расширенная очистка таблиц

**Назначение:** Очистка таблиц прокси, объявлений, артикулов и всех таблиц задач.

**Режимы:**
- `all` — очистка всех указанных таблиц (прокси, результаты парсинга, артикулы, задачи, фильтры)
- `select` — выборочная очистка с интерактивным меню

**Таблицы для очистки:**
- `proxies` — прокси
- Таблица результатов парсинга
- `articulums` — артикулы
- `catalog_tasks` — задачи парсинга каталогов
- `object_tasks` — задачи парсинга объявлений
- Таблицы фильтров повторного парсинга
- `validation_results` — результаты валидации

**Особенности:**
- TRUNCATE CASCADE для удаления связанных данных
- Тройное подтверждение для режима `all`
- Двойное подтверждение для режима `select`

---

# ИНВАРИАНТЫ

- Python 3.11+
- Playwright Chromium
- Зависимости: avito-library, asyncpg, aiohttp, openai
- Только Playwright для сети (без requests/aiohttp)
- Детекторы вызываются после каждого goto и значимого действия → см. [МЕХАНИКА-DETECTORS]
- Браузер создаётся при взятии первой задачи (lazy initialization) и пересоздается при каждой смене прокси из-за ограничений Playwright API. Контекст и страница пересоздаются вместе с браузером → см. [МЕХАНИКА-PROXY]
- Один воркер — один DISPLAY (не меняется) — один браузер в момент времени (пересоздаётся при смене прокси) — один контекст и одна страница (пересоздаются вместе с браузером)
- Все переменные конфигурации указываются в Docker Compose

**Переменные окружения Docker Compose:**
- `REPARSE_MODE` (true/false) — переключение в режим повторного парсинга → см. [МЕХАНИКА-REPARSE]
- `MIN_REPARSE_INTERVAL_HOURS` — минимальный интервал между парсингами одного объявления (часы) → см. [МЕХАНИКА-REPARSE]
- `MAX_CATALOG_WORKERS`, `MAX_OBJECT_WORKERS`, `TOTAL_BROWSER_WORKERS` → см. [МЕХАНИКА-DYNAMIC]
- `FIREWORKS_API_KEY` — API ключ для ИИ-валидации → см. [МЕХАНИКА-VALIDATION]
- `MIN_PRICE` — минимальная цена объявления (дешевле → игнорируем при валидации) → см. [МЕХАНИКА-PRICE-FILTER]
- `MIN_VALIDATED_ITEMS` — минимальное количество объявлений после каждого этапа валидации → см. [МЕХАНИКА-VALIDATION]

---

**✅ ДОКУМЕНТ ЗАВЕРШЕН**

Зафиксировано только обсужденное, без выдуманных деталей.
