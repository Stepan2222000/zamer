

**ОБЯЗАТЕЛЬНО НАДО ПЕРИОДИЧЕСКИ ОБНОВЛЯТЬ И ДОБАВЛЯТЬ ИНФОРМАЦИЮ В ЭТОТ ФАЙЛ И СЛЕДИТЬ ЗА ТЕМ, ЧТОБЫ ИНФОРМАЦИЯ НЕ ПРОТИВОРЕЧИЛА РЕАЛЬНОСТИ И ПРОЧИМ ДОКУМЕНТАЦИЯМ**

ОБЯЗАТЕЛЬНО ВСЕ РЕАЛИЗУЕМ ПО ПРИНЦИПАМ KISS и DRY
КОД И ЛОГИКА НЕ ДОЛЖНЫ ДУБЛИРОВАТЬСЯ, ВСЕ ДОЛЖНО БЫТЬ МАКСИМЛЬНО ПРОСТЫМ

## Обзор проекта

Автоматизированная система для парсинга объявлений с Авито по артикулам с многоуровневой валидацией и распределенной обработкой через независимые воркеры.

**Основные принципы:**
- Никогда не врать - если что-то неизвестно, так и говорить
- Комментарии должны быть краткими и просто описывать, что делает блок кода (без лишних подробностей)
- При необходимости использовать web search
- Не создавать версии проекта и не упоминать версионирование
- Всегда актуализировать документацию
  
**ВАЖНО:** Проект состоит из двух основных папок: `container` и `scripts`

**КРИТИЧЕСКИ ВАЖНО:** Все команды docker compose ДОЛЖНЫ выполняться ТОЛЬКО из каталога контейнера (`container/`)

Вся разная логика должна разделяться на разные файы

Важно уточить, что во время работы можно менять структуру бд
Сами таблицы созадются и меняются постеменно, по мере необходмсоти

Используем самые новые версии библиотек

Браузер и страница
Один воркер = один DISPLAY = один браузер = одна страница в момент времени
DISPLAY не меняется в течение жизни воркера
Страница живет максимально долго и обрабатывает много задач подряд
После каждого page.goto() обязательно вызывается детектор состояния
При смене прокси закрывается весь браузер, а не только страница
Детекторы
Детекторы проверяются в порядке приоритета: успешные состояния → проблемы
Одна общая функция обработки детекторов для catalog и object задач (без дублирования кода)


Прокси
Блокировка прокси постоянная (механизма разблокировки нет)
При блокировке прокси (403, AUTH) воркер меняет прокси БЕЗ возврата задачи
При нерешенной капче прокси возвращается в пул вместе с задачей
Атомарная выдача прокси через SELECT FOR UPDATE SKIP LOCKED
Задачи
Атомарная выдача задач (одна задача = один воркер)
Приоритет: сначала пробуем взять catalog_task, потом object_task
Лимиты контролируются через COUNT активных задач в транзакции
Нет retry-счетчиков (задача может пройти через неограниченное количество прокси)

State Machine
Переходы только вперед (откатов нет)
Артикул не переходит в CATALOG_PARSED пока ВСЕ страницы каталога не обработаны
Объявления одного артикула валидируются как единый батч
Записи в object_tasks создаются ТОЛЬКО после перехода в VALIDATED


Heartbeat
Воркер периодически обновляет heartbeat для текущей задачи
Фоновая задача проверяет обе таблицы (catalog_tasks и object_tasks)
При просрочке heartbeat задача возвращается в pending с сохранением чекпоинта


Воркеры
Воркеры НЕ взаимодействуют напрямую (только через PostgreSQL)
Режим воркера (catalog/object) хранится в памяти процесса



Validation Workers
Validation Workers работают БЕЗ браузера (без Playwright, Xvfb, DISPLAY)
Validation Workers берут артикулы целиком по статусу CATALOG_PARSED (не задачи из очереди)
ИИ-валидация применяется только к объявлениям, прошедшим механическую
Обе валидации (механическая и ИИ) должны пройти для создания object_task
Graceful degradation: если нет GEMINI_API_KEY — программа останаваливается


Парсинг через avito-library
parse_catalog_until_complete сам решает капчи (воркер не решает вручную)
parse_catalog_until_complete работает батчами страниц (не постранично)
page_provider вызывается только при блокировке прокси (не при капче)
Парсинг продолжается с полученной страницы (не перезапуск сначала)


Чекпоинты
Чекпоинт = номер последней обработанной страницы каталога
При heartbeat timeout новый воркер продолжает с чекпоинта (не начинает сначала)
Чекпоинт сохраняется в catalog_tasks

Обработка детекторов
Детекторы вызываются после значимых действий (не только после goto)
REMOVED_DETECTOR_ID → задача invalid (не failed)
NOT_DETECTED_STATE_ID → задача failed без retry
Исключения page.goto() (timeout, network error) → задача возвращается в очередь


Управление ресурсами
При отсутствии свободных прокси воркер приостанавливает взятие задач и ждет
При падении воркера: освобождение ресурсов (прокси, задачи), затем перезапуск
Прокси помечается «используется» с привязкой к worker_id
Прокси помечается «заблокирован» в БД (постоянно)


Система
Создание TOTAL_BROWSER_WORKERS дисплеев Xvfb при старте контейнера
Воркеры запускаются через asyncio.create_subprocess_exec
Главный процесс проверяет статус subprocesses для мониторинга
Heartbeat-механизм проверяет обе таблицы (catalog_tasks и object_tasks)


ЗАПРЕЩЕНО
Использовать requests/aiohttp (только Playwright для всех сетевых операций)
Дублировать логику обработки детекторов между catalog и object
Откатывать артикул назад по state machine
Разблокировать прокси после блокировки
Использовать счетчики retry для задач
Менять DISPLAY у воркера во время работы
Иметь больше одной страницы у воркера одновременно