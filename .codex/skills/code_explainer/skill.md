---
name: code-explainer
description: >
  Глубокий анализ кодовой базы и объяснение пайплайна системы. 
  Используй когда пользователь просит объяснить код, проанализировать архитектуру, 
  понять как работает система, описать пайплайн, разобраться в кодовой базе. 
  Триггеры: объясни код, как работает, проанализируй, опиши пайплайн, 
  разбери архитектуру, explain code, analyze pipeline.
---

# Code Explainer

Анализирует кодовую базу и создаёт понятное объяснение пайплайна системы на русском языке.

## Процесс анализа

### 1. Получить scope анализа

Пользователь указывает папки/файлы для анализа. Если не указал — спросить.

### 2. Собрать структуру проекта

Выполнить `view` на указанные папки для получения дерева файлов.

### 3. Определить entry points

Искать точки входа в порядке приоритета:

**Оркестрация:**
- `docker-compose.yml`, `docker-compose.yaml`
- `Makefile`
- `Dockerfile`

**Python:**
- `main.py`, `app.py`, `run.py`
- `__main__.py`
- Файлы с `if __name__ == '__main__'`

**JavaScript/TypeScript:**
- `package.json` → поле `main` или `scripts.start`
- `index.js`, `index.ts`, `server.js`, `app.js`

**Go:**
- `main.go`
- `cmd/*/main.go`

**Другие языки:**
- Искать паттерны `main`, `entry`, `start`, `run` в именах файлов
- Смотреть конфиги сборки

### 4. Глубокий анализ всех файлов

**Читать ВСЕ файлы** в указанном scope через `view`. Для каждого файла определить:
- Назначение модуля
- Ключевые классы/функции и их роли
- Зависимости (импорты)
- Как связан с другими модулями

### 5. Построить пайплайн

Проследить flow выполнения от entry point:
- Что вызывается первым
- Какие модули инициализируются
- Как данные движутся между компонентами
- Какие этапы обработки существуют

### 6. Создать документ

Сгенерировать Markdown документ согласно формату вывода.

## Формат вывода

Создать **единый связный документ** на русском языке, где пайплайн, компоненты и entry points переплетаются в естественном повествовании.

### Структура документа

```markdown
# [Название системы] — Объяснение пайплайна

## Обзор системы

Краткое описание: что делает система, какие технологии использует, из каких основных частей состоит.

## Пайплайн

Последовательное объяснение работы системы от запуска до завершения. Каждый этап описывает:
- Что происходит
- Какой код за это отвечает (файл:строка-строка)
- Как связано с предыдущим/следующим этапом
```

### Правила оформления

**Ссылки на код:**
- Формат: `файл:строка-строка` относительно корня проекта
- Пример: `src/workers/parser.py:45-67`
- Указывать для каждого значимого компонента

**Стиль повествования:**
- Писать как объяснение для разработчика, который хочет понять систему
- Связывать этапы логически: "После этого...", "Затем...", "Когда X завершается..."
- Объяснять ПОЧЕМУ так сделано, если это очевидно из кода

**Внешние зависимости:**
- Упоминать кратко: "используется библиотека X для Y"
- Не анализировать внутренности внешних библиотек

**Конфигурация:**
- Упоминать в контексте, где используется
- Не выделять в отдельную секцию

## Пример вывода

```markdown
# Avito Parser — Объяснение пайплайна

## Обзор системы

Распределённая система парсинга объявлений Avito. Использует Python, asyncio, Playwright для браузерной автоматизации, PostgreSQL для хранения. Состоит из оркестратора, browser workers и validation workers.

## Пайплайн

### Запуск системы

Система запускается через `docker-compose.yml:22-86`, который поднимает контейнер `parser`. Точка входа — `main.py:520-527`, где вызывается `asyncio.run(main())`.

Функция `main()` создаёт экземпляр `MainProcess` (`main.py:42-50`) и настраивает обработчики сигналов для graceful shutdown (`main.py:499-507`).

### Инициализация

`MainProcess.run()` (`main.py:436-496`) выполняет трёхэтапную инициализацию:

**Этап 1:** Создание виртуальных дисплеев через `xvfb_manager.init_xvfb_displays()` (`xvfb_manager.py:135-157`). Каждый browser worker получает свой DISPLAY для изоляции.

**Этап 2:** Подключение к PostgreSQL через `database.create_pool()` (`database.py:12-14`). Настройки берутся из `config.py:14-20`.

**Этап 3:** Запуск воркеров. `spawn_browser_workers()` (`main.py:229-253`) создаёт N subprocess'ов, каждый выполняет `browser_worker.py`. Параллельно `spawn_validation_workers()` (`main.py:255-279`) запускает воркеры валидации.

### Обработка задач

Browser workers в `main_loop()` (`browser_worker.py:674-739`) динамически выбирают тип задачи на основе размера буфера каталогов...

[продолжение]
```

## Важно
- **Результат:** создать файл markdown и зафиксировать в него всю информацию
- **Язык:** Всегда русский
- **Глубина:** Анализировать ВСЕ файлы в указанном scope
- **Формат ссылок:** `файл:строка-строка`
- **Структура:** Единое повествование, не разбитое на изолированные секции
- **Фокус:** Объяснить КАК работает система, проследить flow от начала до конца