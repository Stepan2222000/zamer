# План интеграции изображений и мультимодальной AI валидации

## Цель

Добавить в систему парсинга возможность:
1. Собирать изображения объявлений при парсинге каталога
2. Сохранять изображения в базу данных
3. Отсеивать объявления без изображений на этапе валидации
4. Передавать изображения в AI для мультимодальной валидации (текст + фото)

---

## Часть 1: Конфигурация

### Новые параметры в config.py

Добавляем раздел "ИЗОБРАЖЕНИЯ" с параметрами:

**Парсинг и хранение:**

| Параметр | Тип | По умолчанию | Описание |
|----------|-----|--------------|----------|
| `COLLECT_IMAGES` | bool | true | Собирать ли изображения при парсинге каталога. Если включено, добавляет поле "images" в запрос к avito-library, и библиотека автоматически скачивает изображения. |
| `SAVE_IMAGES_BYTES` | bool | true | Сохранять ли байты изображений в БД. Если выключено — сохраняются только URLs и количество. Для AI валидации с изображениями должно быть включено. |
| `MAX_IMAGES_PER_LISTING` | int | 5 | Максимальное количество изображений для сохранения на одно объявление. avito-library возвращает до 5 изображений, можно ограничить меньшим числом для экономии места. |

**Валидация:**

| Параметр | Тип | По умолчанию | Описание |
|----------|-----|--------------|----------|
| `REQUIRE_IMAGES` | bool | true | Требовать наличие изображений при валидации. Если включено — объявления без фото отклоняются на этапе mechanical validation с причиной "Объявление без изображений". |
| `AI_USE_IMAGES` | bool | true | Отправлять ли изображения в AI валидацию. Работает только если `SAVE_IMAGES_BYTES=true`. Если выключено — AI работает только с текстом (как раньше). |
| `AI_MAX_IMAGES_PER_LISTING` | int | 2 | Сколько изображений отправлять в AI на одно объявление. Рекомендуется 1-2 для экономии токенов. Должно быть не больше `MAX_IMAGES_PER_LISTING`. |

### Логика взаимосвязи параметров

```
COLLECT_IMAGES = false
    → Изображения не собираются вообще
    → Все остальные параметры изображений игнорируются
    → Система работает как раньше (только текст)

COLLECT_IMAGES = true, SAVE_IMAGES_BYTES = false
    → Собираем и сохраняем только URLs и количество
    → REQUIRE_IMAGES работает (проверка "есть фото / нет фото")
    → AI_USE_IMAGES автоматически выключается (нет байтов)

COLLECT_IMAGES = true, SAVE_IMAGES_BYTES = true
    → Полный функционал: URLs + байты + count
    → REQUIRE_IMAGES работает
    → AI_USE_IMAGES работает
    → AI_MAX_IMAGES_PER_LISTING контролирует нагрузку на AI
```

---

## Часть 2: База данных

### Миграция таблицы catalog_listings

Добавляем три новые колонки в существующую таблицу `catalog_listings`:

**images_urls (JSONB)**
- Хранит JSON-массив строк с URL изображений
- Пример: `["https://...", "https://..."]`
- Сохраняется всегда при `COLLECT_IMAGES=true`
- Полезно для отладки и возможного повторного скачивания

**images_bytes (BYTEA[])**
- Хранит массив бинарных данных (байты изображений)
- Нативный тип PostgreSQL для массива бинарных объектов
- Сохраняется только при `SAVE_IMAGES_BYTES=true`
- asyncpg автоматически конвертирует Python `list[bytes]` в этот тип

**images_count (SMALLINT)**
- Хранит количество изображений (0-5)
- Нужно для быстрой фильтрации без загрузки тяжёлых данных
- Позволяет эффективно искать объявления без фото
- Добавляем индекс для быстрых запросов

### Скрипт миграции

Создаём файл `scripts/migrate_add_images.py` который:
1. Добавляет колонки если их нет (идемпотентно)
2. Создаёт индекс по `images_count`
3. Логирует результат

---

## Часть 3: Парсер каталога

### Изменения в catalog_parser.py

**Динамическое формирование списка полей:**

Сейчас `CATALOG_FIELDS` — статический список в config.py. Нужно сделать его динамическим:
- Если `COLLECT_IMAGES=true` — добавляем `"images"` в список полей
- Если `COLLECT_IMAGES=false` — список остаётся как раньше

Это можно реализовать:
- Либо функцией `get_catalog_fields()` в config.py
- Либо условной логикой в catalog_parser.py при вызове `parse_catalog`

**Сохранение изображений в БД:**

Изменяем функцию `save_listings_to_db`:
1. Извлекаем из объекта `CatalogListing` поля `images`, `images_urls`
2. Ограничиваем количество по `MAX_IMAGES_PER_LISTING`
3. Если `SAVE_IMAGES_BYTES=false` — сохраняем только URLs и count
4. Если `SAVE_IMAGES_BYTES=true` — сохраняем также байты
5. Всегда сохраняем `images_count` для быстрой фильтрации

**Обработка случаев:**
- Если `listing.images` пустой список `[]` — объявление без фото, `images_count=0`
- Если `listing.images` это `None` — поле не запрашивалось, `images_count=NULL`
- При ошибках скачивания (`images_errors`) — логируем, но не падаем

---

## Часть 4: Воркер валидации

### Изменения в validation_worker.py

**Получение данных с изображениями:**

Изменяем метод `get_listings_for_articulum`:
- Добавляем в SELECT колонки `images_bytes`, `images_count`
- Если `AI_USE_IMAGES=false` — можно не запрашивать `images_bytes` для экономии

**Новая проверка в mechanical_validation:**

Добавляем проверку наличия изображений в начало цикла валидации:
- Если `REQUIRE_IMAGES=true` и `images_count=0` — отклоняем
- Причина отклонения: "Объявление без изображений"
- Сохраняем результат в `validation_results` с типом `mechanical`

Эта проверка идёт ПЕРЕД остальными проверками (стоп-слова, цена, артикул), чтобы сразу отсеять объявления без фото.

**Мультимодальная AI валидация:**

Изменяем метод `ai_validation`:

Если `AI_USE_IMAGES=false`:
- Работает как раньше — только текстовый промпт
- Изображения не передаются

Если `AI_USE_IMAGES=true`:
- Формируем мультимодальный запрос с текстом и изображениями
- Берём первые `AI_MAX_IMAGES_PER_LISTING` изображений для каждого объявления
- Кодируем байты в base64 для передачи в AI API
- Обновляем промпт с инструкциями по анализу изображений

**Обновлённый промпт для мультимодальной валидации:**

Добавляем критерии проверки по изображениям:
1. Фото соответствует описанию товара (не сток-фото, не случайное изображение)
2. На фото видна оригинальная упаковка или маркировка производителя
3. Состояние товара — НОВОЕ (нет следов использования, царапин, потёртостей)
4. На фото действительно автозапчасть, а не что-то другое

Текстовые критерии остаются как раньше:
1. Нет признаков неоригинальности в тексте
2. Артикул соответствует товару
3. Цена адекватная для оригинала

---

## Часть 5: Абстракция AI провайдера

### Новый модуль ai_provider.py

Создаём базовый класс `AIValidationProvider` с интерфейсом:
- Метод `validate(articulum, listings)` — принимает артикул и список объявлений
- Возвращает результат с `passed_ids` и `rejected` (с причинами)
- Метод `close()` для освобождения ресурсов

**Заглушка DummyProvider:**

Временная реализация, которая пропускает все объявления без реальной проверки. Нужна для:
- Тестирования пайплайна без настройки AI
- Режима работы когда AI временно недоступен

**Будущие провайдеры:**

Структура позволяет легко добавить:
- `GeminiProvider` — Google Vertex AI с Gemini
- `OpenAIProvider` — OpenAI GPT-4o
- `ClaudeProvider` — Anthropic Claude
- `CustomProvider` — твоя кастомная модель

Выбор провайдера через `AI_PROVIDER` в config.py.

---

## Часть 6: Порядок реализации

### Этап 1: Подготовка БД

1. Создать скрипт миграции `scripts/migrate_add_images.py`
2. Запустить миграцию на базе данных
3. Проверить что колонки добавлены корректно

### Этап 2: Конфигурация

1. Добавить новые параметры в `config.py`
2. Добавить валидацию параметров (например, `AI_MAX_IMAGES <= MAX_IMAGES`)
3. Добавить логирование активных настроек при старте

### Этап 3: Парсер каталога

1. Изменить формирование `CATALOG_FIELDS` (динамически добавлять `images`)
2. Изменить `save_listings_to_db` для сохранения изображений
3. Протестировать парсинг с `COLLECT_IMAGES=true`
4. Проверить что данные корректно сохраняются в БД

### Этап 4: Валидация (mechanical)

1. Изменить `get_listings_for_articulum` для получения изображений
2. Добавить проверку `REQUIRE_IMAGES` в `mechanical_validation`
3. Протестировать отсев объявлений без фото

### Этап 5: AI провайдер

1. Создать модуль `ai_provider.py` с базовым классом
2. Реализовать `DummyProvider` как заглушку
3. Подключить провайдер в `validation_worker.py`

### Этап 6: AI валидация с изображениями

1. Обновить метод `ai_validation` для мультимодального режима
2. Обновить промпт с критериями анализа изображений
3. Добавить логику кодирования изображений в base64
4. Протестировать с DummyProvider

### Этап 7: Интеграционное тестирование

1. Прогнать полный цикл: парсинг → валидация → сохранение
2. Проверить все комбинации параметров
3. Проверить обработку ошибок (нет изображений, ошибки AI)

---

## Риски и решения

### Риск: Раздувание БД из-за изображений

**Проблема:** 5 изображений × 100KB = 500KB на объявление. При 100,000 объявлений — 50GB.

**Решения:**
- Параметр `SAVE_IMAGES_BYTES=false` для режима без хранения байтов
- Параметр `MAX_IMAGES_PER_LISTING` для ограничения количества
- Периодическая очистка старых данных (если нужно)

### Риск: Высокая стоимость AI токенов

**Проблема:** Изображения в промпте стоят много токенов.

**Решения:**
- Параметр `AI_MAX_IMAGES_PER_LISTING` (рекомендуется 1-2)
- Изображения уже сжаты до 636w avito-library
- При необходимости — дополнительное сжатие перед отправкой

### Риск: Большой отсев объявлений

**Проблема:** По примерным оценкам ~74% объявлений без фото.

**Решения:**
- Параметр `REQUIRE_IMAGES=false` для режима без обязательных фото
- Это бизнес-решение — если цель качественная AI валидация по фото, отсев оправдан

### Риск: AI провайдер недоступен

**Проблема:** Ошибки API, таймауты, лимиты.

**Решения:**
- Существующий механизм rollback артикула в `CATALOG_PARSED`
- Счётчик ошибок и graceful shutdown воркера
- DummyProvider как fallback

---

## Файлы для изменения

| Файл | Тип изменения | Описание |
|------|---------------|----------|
| `config.py` | Изменение | Новые параметры для изображений |
| `catalog_parser.py` | Изменение | Сохранение изображений в БД |
| `validation_worker.py` | Изменение | Проверка наличия фото, мультимодальная AI валидация |
| `ai_provider.py` | Новый файл | Абстракция AI провайдеров |
| `scripts/migrate_add_images.py` | Новый файл | Миграция БД |
| `scripts/schema.sql` | Изменение | Документирование новых колонок |

---

## Тестирование

### Сценарии для проверки

1. **COLLECT_IMAGES=false** — система работает как раньше, изображения не собираются
2. **COLLECT_IMAGES=true, SAVE_IMAGES_BYTES=false** — сохраняются только URLs и count
3. **COLLECT_IMAGES=true, REQUIRE_IMAGES=true** — объявления без фото отклоняются
4. **COLLECT_IMAGES=true, AI_USE_IMAGES=true** — мультимодальная валидация
5. **Объявление с 5 фото, MAX_IMAGES=3** — сохраняются только первые 3
6. **Объявление без фото, REQUIRE_IMAGES=false** — проходит валидацию
7. **Ошибка AI API** — артикул возвращается в очередь

---

## Статус

- [ ] Часть 1: Конфигурация
- [ ] Часть 2: Миграция БД
- [ ] Часть 3: Парсер каталога
- [ ] Часть 4: Валидация (mechanical)
- [ ] Часть 5: AI провайдер
- [ ] Часть 6: AI валидация с изображениями
- [ ] Интеграционное тестирование
